# [알파벳(1987번)](https://www.acmicpc.net/problem/1987)

## 문제  
***세로 R칸, 가로 C칸으로 된 표 모양의 보드가 있다. 보드의 각 칸에는 대문자 알파벳이 하나씩 적혀 있고, 좌측 상단 칸 (1행 1열) 에는 말이 놓여 있다.
말은 상하좌우로 인접한 네 칸 중의 한 칸으로 이동할 수 있는데, 새로 이동한 칸에 적혀 있는 알파벳은 지금까지 지나온 모든 칸에 적혀 있는 알파벳과는 달라야 한다.
즉, <U>같은 알파벳이 적힌 칸을 두 번 지날 수 없다.</U>
좌측 상단에서 시작해서, 말이 최대한 몇 칸을 지날 수 있는지를 구하는 프로그램을 작성하시오. 말이 지나는 칸은 좌측 상단의 칸도 포함된다.***

## 풀이
DFS를 이용한 전형적인 탐색 문제이다.  
하나의 정점을 시작으로 특정 조건에 따른 최대(깊이우선) 경로를 찾아야 하기 때문에, BFS보다는 DFS가 적절하다.
DFS알고리즘은 보통 ```재귀함수```로 작성하는 특징이 있다.  
깊이 우선 탐색 후, 어느 정점에서 더 이상 진행이 불가능 할 때, 백트래킹을 하여 이전 정점부터 다시 DFS를 진행하도록 한다. 

방문 했던 알파벳이 존재하는 경우 두 번 지날 수 없기 때문에, ```방문 했던 알파벳을 저장하는 벡터를 따로 생성```하여 방문 여부를 판단 한다.
만약, 현재 정점에서 상하좌우로 더 이상 진행이 불가능 한 경우, 백트래킹을 실시한다. 이때, 이전 정점으로 정보가 되돌아 가므로, ```현재 방문 했던
알파벳 데이터는 벡터에서 pop하는 것```에 유의한다.

**변수**
- 보드판 배열(2차원)
- 방문한 알파벳 저장 벡터(char형 벡터)
- 경로 횟수 MAX값

**함수**
- 상하좌우 범위 체크 함수
- 방문가능 체크 함수(방문했던 알파벳 체크)
- DFS 함수 (파라미터 : y(위치 좌표),x(위치 좌표),cnt(해당 좌표까지 경로횟수))
- 최대 경로 횟수 구하는 함수(지금까지 방문한 경로 중 최대 경로 횟수 저장)

## [소스코드](https://github.com/foreverever/baekjoon/blob/master/baekjoon/%EC%95%8C%ED%8C%8C%EB%B2%B3(1987).cpp)

## 부족한 부분
재귀함수의 파라미터와 종료조건을 만드는게 생각보다 유연하지 않다.
재귀에 대한 이해와, 사용방법 등이 익숙하지 않다는 의미이다. 재귀 관련 문제를 많이 풀어보면 좋을 듯 싶다.

## 내일 할 일
- 알고리즘 1문제
- 자바 강의 듣기